{%- comment -%} Block Product Form (brains) {%- endcomment -%}
{%- assign p = product -%}
{%- if p == blank and section.settings.product != blank -%}
  {%- assign p = section.settings.product -%} {# <-- geen all_products[] #}
{%- endif -%}

{%- if p != blank -%}
  <div class="pform"
       data-product-form
       data-section-id="{{ section.id }}"
       data-product-json="{{ p | json | escape }}">
    <form action="/cart/add" method="post" id="{{ product_form_id }}" class="pform__form" novalidate>
      {%- assign first_variant_id = p.selected_or_first_available_variant.id -%}
      <input type="hidden" name="id" value="{{ first_variant_id }}" data-variant-id>
  
      {%- assign block_order_json = section.blocks | map: 'id' | json -%}
      <div class="pform__segments"
           data-fragment-parent="product-form"
           data-block-order='{{ block_order_json | escape }}'>
  
        {%- for block in section.blocks -%}
          <div class="pform__block"
               data-block-key="{{ block.id }}"
               data-fragment="{{ block.type }}"
               {{ block.shopify_attributes }}>
            {%- case block.type -%}
              {%- when 'heading' -%}
                {% render 'html-product-heading', product: p, text: block.settings.text %}
  
              {%- when 'variant_picker' -%}
                {% render 'html-product-variant_picker', product: p, threshold_dropdown: block.settings.threshold_dropdown %}
  
              {%- when 'price' -%}
                {% render 'html-product-price', product: p, show: true %}
  
              {%- when 'stock' -%}
                {% render 'html-product-stock', product: p, show: true %}
  
              {%- when 'sku' -%}
                {% render 'html-product-sku', product: p, show_label: block.settings.show_label %}
  
              {%- when 'quantity' -%}
                {% render 'html-product-quantity', product: p %}
  
              {%- when 'selling_plans' -%}
                {% render 'html-product-selling_plans', product: p %}
  
              {%- when 'atc' -%}
                {% render 'html-product-atc', product: p, full_width: block.settings.full_width %}
  
              {%- when 'dynamic_checkout' -%}
                {% render 'html-product-dynamic_checkout', product: p %}
            {%- endcase -%}
          </div>
        {%- endfor -%}
  
      </div>
    </form>
  </div>

{%- else -%}
  <div class="pform pform--empty">
    <p>{{ 'products.product.product_unavailable' | t | default: 'Selecteer een product in de sectie-instellingen.' }}</p>
  </div>
{%- endif -%}

{%- stylesheet -%}
.pform{display:grid;gap:1rem}
.pform__label{font-weight:600}
.pform__btn{min-height:48px}
{%- endstylesheet -%}

<script>
(() => {
  // ---------- Boot ----------
  const READY = /complete|interactive/;
  const onReady = fn => READY.test(document.readyState) ? fn() : document.addEventListener('DOMContentLoaded', fn);

  onReady(() => {
    // Dev-sanity: verwijder dubbele preconnects/prefetches (no-op in live)
    dedupeResourceHints();

    document.querySelectorAll('[data-product-form]').forEach(root => initProductForm(root));
  });

  // ---------- Init per section ----------
  function initProductForm(root){
    const sectionId = root.getAttribute('data-section-id');
    const product   = safeJSON(root.getAttribute('data-product-json'));
    const segments  = root.querySelector('[data-fragment-parent="product-form"]');
    if (!sectionId || !product || !segments) return;

    let inflight;               // AbortController voor fetches
    let prevState = snapshotState(root);

    root.addEventListener('change', (ev) => {
      if (!ev.target.closest('form')) return;

      // 1) Bepaal huidige variant vanuit UI
      const variant = findVariant(product, readCurrentOptions(root, product));

      // 2) Snelle client-side updates (prijs/ATC), voelt snappy
      quickClientUpdates(root, variant);

      // 3) Check of iets relevants echt veranderde
      const nextState = snapshotState(root);
      if (equalStates(prevState, nextState)) return;
      prevState = nextState;

      // 4) Sharable URL (werkt voor multi-option)
      if (nextState.variantId) pushVariantToURL(nextState.variantId);

      // 5) Haal alleen server truth op en reconcile blokken
      inflight = fetchAndReplaceFragments(root, sectionId, nextState, inflight);
    });
  }

  // ---------- Helpers: variant/selectie ----------
  function readCurrentOptions(root, product){
    return (product.options || []).map((name, idx) => {
      const sel = root.querySelector(`[data-option-select][data-option-index="${idx}"]`);
      if (sel) return sel.value;
      const checked = root.querySelector(`input[name="options[${CSS.escape(name)}]"]:checked`);
      if (checked) return checked.value;
      const owv = product.options_with_values && product.options_with_values[idx];
      return owv ? owv.selected_value : null;
    });
  }
  function findVariant(product, opts){
    return product.variants.find(v => v.options.every((val,i) => val === opts[i]));
  }

  // ---------- Helpers: state & URL ----------
  function snapshotState(root){
    return {
      variantId:   (root.querySelector('[data-variant-id]') || {}).value || '',
      sellingPlan: (root.querySelector('[name="selling_plan"]') || {}).value || '',
      quantity:    (root.querySelector('input[name="quantity"]') || {}).value || '',
      focusSel: (() => {
        const a = document.activeElement;
        if (!a || !root.contains(a)) return '';
        if (a.id) return '#' + CSS.escape(a.id);
        const n = a.getAttribute('name'); if (n) return `[name="${CSS.escape(n)}"]`;
        return '';
      })(),
      scrollY: window.scrollY
    };
  }
  function equalStates(a,b){
    return a.variantId === b.variantId &&
           a.sellingPlan === b.sellingPlan &&
           a.quantity === b.quantity;
  }
  function pushVariantToURL(variantId){
    const url = new URL(window.location.href);
    url.searchParams.set('variant', variantId);
    history.replaceState({}, '', url.toString());
  }

  // ---------- Snelle client updates ----------
  function quickClientUpdates(root, variant){
    // Hidden variant id
    const idEl = root.querySelector('[data-variant-id]');
    if (variant?.id && idEl) idEl.value = variant.id;

    // Prijs (client-side, server refresh volgt)
    if (variant && typeof variant.price === 'number' && window.Shopify?.formatMoney) {
      root.querySelectorAll('[data-fragment="price"] [data-price]').forEach(el => el.textContent = Shopify.formatMoney(variant.price));
      root.querySelectorAll('[data-fragment="price"] [data-compare-at]').forEach(el => {
        if (typeof variant.compare_at_price === 'number' && variant.compare_at_price > variant.price) {
          el.textContent = Shopify.formatMoney(variant.compare_at_price);
          el.hidden = false;
        } else el.hidden = true;
      });
    }

    // ATC state
    root.querySelectorAll('[data-fragment="atc"] [data-atc]').forEach(btn => {
      const txt = btn.querySelector('[data-atc-text]') || btn;
      if (!variant) {
        btn.disabled = true; txt.textContent = btn.getAttribute('data-label-unavailable') || 'Unavailable';
      } else if (variant.available) {
        btn.disabled = false; txt.textContent = btn.getAttribute('data-label-default') || 'Add to cart';
      } else {
        btn.disabled = true; txt.textContent = btn.getAttribute('data-label-soldout') || 'Sold out';
      }
    });
  }

  // ---------- Fetch + Reconcile ----------
  async function fetchAndReplaceFragments(root, sectionId, state, prevCtrl){
    prevCtrl?.abort?.();
    const ctrl = new AbortController();
  
    const url = new URL(window.location.href);
    // Option 1: keep section_id (your current path)
    url.searchParams.set('section_id', sectionId);
  
    if (state.variantId)   url.searchParams.set('variant', state.variantId); else url.searchParams.delete('variant');
    if (state.sellingPlan) url.searchParams.set('selling_plan', state.sellingPlan); else url.searchParams.delete('selling_plan');
  
    // DEV: force-unique URL to avoid 304/old bodies
    if (isDevEnv()) url.searchParams.set('_cb', cacheBuster());
  
    root.classList.add('is-rendering');
  
    try {
      const res = await fetch(url.toString(), {
        method: 'GET',
        headers: {
          'X-Requested-With': 'XMLHttpRequest',
          // strong anti-cache hints (some proxies respect these):
          'Cache-Control': 'no-cache, no-store, max-age=0, must-revalidate',
          'Pragma': 'no-cache',
          'Expires': '0'
        },
        cache: isDevEnv() ? 'no-store' : 'default', // safari likes 'reload' too if needed
        signal: ctrl.signal,
        credentials: 'same-origin'
      });
  
      if (res.status === 304) return ctrl;        // nothing changed â†’ skip
      if (!res.ok) { console.warn('Section render non-200', res.status); return ctrl; }
  
      const html = await res.text();
      // Quick sanity: if your stock snippet had '-x-' marker in dev,
      // you can assert it's present:
      // if (isDevEnv() && !html.includes('-x-')) console.warn('Dev cache still stale?');
  
      const tpl = document.createElement('template');
      tpl.innerHTML = html;
  
      // strip noisy tags that sometimes get injected in dev
      tpl.content.querySelectorAll('script, link[rel="preconnect"], link[rel="prefetch"]').forEach(n => n.remove());
  
      // Reconcile blocks (your existing function)
      reconcileBlocks(root, tpl.content, {
        replaceTypes: ['price','stock','sku','selling_plans','atc'],
        addIfMissing: true,
        removeIfGone: true
      });
  
      // Restore small state
      const qty = root.querySelector('input[name="quantity"]'); if (qty && state.quantity) qty.value = state.quantity;
      const sp  = root.querySelector('[name="selling_plan"]'); if (sp && state.sellingPlan) sp.value = state.sellingPlan;
      if (state.focusSel) { const f = root.querySelector(state.focusSel); try { f?.focus({preventScroll:true}); } catch(e){} }
      window.scrollTo({ top: state.scrollY });
  
    } catch (e) {
      if (e.name !== 'AbortError') console.error('Fragment render failed', e);
    } finally {
      root.classList.remove('is-rendering');
    }
  
    return ctrl;
  }

  // ---------- Reconcile volgens server volgorde ----------
  function reconcileBlocks(root, incoming, { addIfMissing = true, removeIfGone = true, replaceTypes = [] } = {}){
    const parentSel = '[data-fragment-parent="product-form"]';
    const curParent = root.querySelector(parentSel);
    const incParent = incoming.querySelector(parentSel);
    if (!curParent || !incParent) return;

    // Servervolgorde ophalen
    let order = [];
    try { order = JSON.parse(incParent.getAttribute('data-block-order') || '[]'); } catch(e){ order = []; }

    // Indexeer huidige & inkomende blokken
    const curByKey = new Map([...curParent.querySelectorAll('[data-block-key]')].map(el => [el.getAttribute('data-block-key'), el]));
    const incByKey = new Map([...incParent.querySelectorAll('[data-block-key]')].map(el => [el.getAttribute('data-block-key'), el]));

    // Mag dit type vervangen?
    const canReplace = (el) => {
      if (!replaceTypes || replaceTypes.length === 0) return true;
      const t = el.getAttribute('data-fragment');
      return replaceTypes.includes(t);
    };

    // Volg servervolgorde bij opbouw
    let insertAfter = null;
    order.forEach(key => {
      const next = incByKey.get(key);
      if (!next) return;
      const cur  = curByKey.get(key);

      if (cur) {
        if (canReplace(cur)) {
          cur.replaceWith(next);
          insertAfter = curParent.querySelector(`[data-block-key="${CSS.escape(key)}"]`);
        } else {
          insertAfter = cur; // niet vervangen, maar wel volgorde respecteren
        }
      } else if (addIfMissing) {
        if (insertAfter && insertAfter.parentNode === curParent) {
          insertAfter.after(next);
        } else {
          curParent.appendChild(next);
        }
        insertAfter = next;
      }
    });

    // Verwijder blokken die de server niet meer noemt
    if (removeIfGone) {
      curParent.querySelectorAll('[data-block-key]').forEach(el => {
        const key = el.getAttribute('data-block-key');
        if (!order.includes(key) && canReplace(el)) el.remove();
      });
    }
  }

  // ---------- Misc helpers ----------
  function safeJSON(str){ try { return JSON.parse(str || '') } catch(_){ return null } }
  function isDevEnv(){
    const h = location.hostname;
    // pick your own heuristic if needed:
    return h === 'localhost' || h === '127.0.0.1' || h.endsWith('.test');
  }
  
  function cacheBuster(){
    // include variant/selling plan to help proxies create unique keys
    return String(Date.now());
  }

  function dedupeResourceHints(){
    const seen = new Set();
    document.querySelectorAll('link[rel="preconnect"], link[rel="prefetch"]').forEach(link => {
      const key = (link.href || '') + '|' + (link.crossOrigin || '');
      if (seen.has(key)) link.remove(); else seen.add(key);
    });
  }
})();
</script>

{%- schema -%}
{
  "name": "Product form",
  "templates": ["product"], 
  "settings": [
    { "type": "product", "id": "product", "label": "Fallback product (niet op PDP)" }
  ],
  "blocks": [
    { "type": "heading", "name": "Heading", "settings": [{ "type":"text","id":"text","label":"Tekst","default":"Koop dit product"}]},
    { "type": "variant_picker", "name": "Variant picker", "settings": [{ "type":"range","id":"threshold_dropdown","min":0,"max":20,"step":1,"label":"Dropdown vanaf aantal opties","default":10 }]},
    { "type": "price", "name": "Prijs", "settings": []},
    { "type": "stock", "name": "Voorraad", "settings": [
      { "type":"text","id":"in_label","label":"Op voorraad label","default":"Op voorraad" },
      { "type":"text","id":"out_label","label":"Niet op voorraad label","default":"Niet op voorraad"}
    ]},
    { "type": "sku", "name": "SKU", "settings": [{ "type":"checkbox","id":"show_label","label":"Toon label","default":true }]},
    { "type": "quantity", "name": "Aantal", "settings": []},
    { "type": "selling_plans", "name": "Abonnementen", "settings": []},
    { "type": "atc", "name": "Add to cart knop", "settings": [{ "type":"checkbox","id":"full_width","label":"Volledige breedte","default":true }]},
    { "type": "dynamic_checkout", "name": "Dynamische checkout", "settings": []}
  ],
  "presets": [
    {
      "name":"Productformulier (blocks)",
      "category": "Products",
      "blocks":[
        {"type":"heading"},
        {"type":"price"},
        {"type":"variant_picker"},
        {"type":"stock"},
        {"type":"quantity"},
        {"type":"atc"},
        {"type":"dynamic_checkout"}
      ]
    }
  ]
}
{%- endschema -%}