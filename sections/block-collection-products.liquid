{%- comment -%}
  ============================================================================
  BLOCK-COLLECTION-PRODUCTS
  ============================================================================
  Product grid with filtering, sorting, and pagination.
  Works for both collection and search pages.

  FEATURES:
  - Faceted filtering (bar + drawer)
  - AJAX grid refresh (Section Rendering API)
  - Facet count sync without DOM replacement
  - Configurable grid columns

  DEPENDENCIES:
  - html-facets-bar snippet
  - html-facets-pills snippet
  - html-facets-drawer snippet
  - html-product-card snippet
  - html-theme-pagination snippet
  ============================================================================
{%- endcomment -%}

{%- liquid
	assign resource = collection
	if resource == blank and search
		assign resource = search
	endif
	
	assign products_per_page = section.settings.products_per_page | default: 24
	assign grid_columns = section.settings.grid_columns | default: 4
	
	comment
		Determine if there are products to show filters for
		Search form uses type=product, so search.results contains only products
	endcomment
	assign has_results = false
	if collection and resource.products_count > 0
		assign has_results = true
	elsif search and search.results_count > 0
		assign has_results = true
	endif
-%}

<div class="block-collection-products__content {{ section.settings.width }}" data-section-root>
	{%- comment -%} Filters {%- endcomment -%}
	{%- liquid
		assign show_filters = false
		if has_results
			if section.settings.show_filter or section.settings.show_sort
				assign show_filters = true
			endif
		endif
	-%}
	{%- if show_filters -%}
		{%- assign sort_by = resource.sort_by | default: resource.default_sort_by -%}
		<product-filter
			class="product-filter"
			data-section-id="{{ section.id }}"
			data-auto-submit="{{ section.settings.auto_submit }}"
			data-auto-fill="{{ section.settings.auto_fill_preview | default: true }}"
			data-max-preview="{{ section.settings.max_preview_filters | default: 8 }}"
		>
			{%- render 'html-facets-bar', object: resource, section_id: section.id, sort_by: sort_by, settings: section.settings -%}
			{%- render 'html-facets-pills', object: resource, section_id: section.id -%}
			{%- render 'html-facets-drawer', object: resource, section_id: section.id, sort_by: sort_by, settings: section.settings -%}
		</product-filter>
	{%- endif -%}

	{%- comment -%} Product Grid {%- endcomment -%}
	<div class="block-collection-products__grid" data-product-grid>
		{%- if resource == blank -%}
			<p class="block-collection-products__empty">{{ 'collection.empty' | t }}</p>
		{%- else -%}
			{%- if collection -%}
				{%- paginate collection.products by products_per_page -%}
					<div id="results-meta" data-count="{{ paginate.items }}"></div>
					<ul id="product-grid" class="block-collection-products__list" style="--grid-columns: {{ grid_columns }}; --grid-columns-tablet: {{ section.settings.grid_columns_tablet }}; --grid-columns-mobile: {{ section.settings.grid_columns_mobile }}; --grid-gap: {{ section.settings.grid_gap }}em;" data-columns="{{ grid_columns }}">
						{%- for product in collection.products -%}
							{%- assign lazy_load = false -%}
							{%- if forloop.index > grid_columns -%}
								{%- assign lazy_load = true -%}
							{%- endif -%}
							<li class="block-collection-products__item">
								{% render 'html-product-card', 
									product: product, 
									layout: section.settings.card_layout,
									lazy_load: lazy_load,
									image_ratio: section.settings.image_ratio,
									show_secondary_image: section.settings.show_secondary_image,
									show_rating: section.settings.show_rating,
									show_vendor: section.settings.show_vendor, 
									show_price: true,
									show_stock: true,
									show_stock_from: 'auto',
									show_delivery: true,
									show_badges: section.settings.show_badges,
									quick_add: section.settings.quick_add
								%}
							</li>
						{%- endfor -%}
					</ul>
					{%- render 'html-theme-pagination', paginate: paginate -%}
				{%- endpaginate -%}
			{%- elsif search -%}
				{%- paginate search.results by products_per_page -%}
					<div id="results-meta" data-count="{{ paginate.items }}"></div>
					{%- if search.results.size == 0 -%}
						<p class="block-collection-products__empty">{{ 'collection.empty' | t }}</p>
					{%- else -%}
						<ul id="product-grid" class="block-collection-products__list" style="--grid-columns: {{ grid_columns }}; --grid-columns-tablet: {{ section.settings.grid_columns_tablet }}; --grid-columns-mobile: {{ section.settings.grid_columns_mobile }}; --grid-gap: {{ section.settings.grid_gap }}em;" data-columns="{{ grid_columns }}">
							{%- for product in search.results -%}
								{%- assign lazy_load = false -%}
								{%- if forloop.index > grid_columns -%}
									{%- assign lazy_load = true -%}
								{%- endif -%}
								<li class="block-collection-products__item">
									{% render 'html-product-card', 
										product: product, 
										layout: section.settings.card_layout,
										lazy_load: lazy_load,
										image_ratio: section.settings.image_ratio,
										show_secondary_image: section.settings.show_secondary_image,
										show_rating: section.settings.show_rating,
										show_vendor: section.settings.show_vendor, 
										show_price: true,
										show_stock: true,
										show_delivery: true,
										show_badges: section.settings.show_badges,
										quick_add: section.settings.quick_add
									%}
								</li>
							{%- endfor -%}
						</ul>
						{%- render 'html-theme-pagination', paginate: paginate -%}
					{%- endif -%}
				{%- endpaginate -%}
			{%- endif -%}
		{%- endif -%}
	</div>
</div>

{% style %}
	.block-collection-products {
		background-color: {{ section.settings.background_color }};
		color: {{ section.settings.text_color }};
		padding-block-start: 2em;
		padding-block-end: 4em;
	}

	.block-collection-products__list {
		display: grid;
		grid-template-columns: repeat(var(--grid-columns, 4), 1fr);
		gap: var(--grid-gap, 0.2em);
		list-style: none;
		padding: 0;
		margin: 0;
	}

	.block-collection-products__item {
		display: block;
		width: 100%;
		min-width: 0;
	}

	.block-collection-products__item > .product-card {
		height: 100%;
	}

	.block-collection-products__empty {
		text-align: center;
		padding: 4em 2em;
		opacity: 0.6;
	}

	@media (max-width: 64em) {
		.block-collection-products__list {
			grid-template-columns: repeat(var(--grid-columns-tablet, 3), 1fr);
		}
	}

	@media (max-width: 47.5em) {
		.block-collection-products__list {
			grid-template-columns: repeat(var(--grid-columns-mobile, 2), 1fr);
		}
	}

	html.is-loading {
		cursor: progress;
	}

	html.is-loading .block-collection-products__list {
		opacity: 0.5;
		pointer-events: none;
	}

	.block-collection-products .pagination {
		margin-block-start: 2em;
	}

	.product-filter {
		display: block;
		padding-block-end: 2em;
	}

	.facets__resultcount {
		letter-spacing: -0.02em;
	}
{% endstyle %}

<script>
/**
 * ProductFilter – AJAX filtering with drawer, bar, and pills sync
 */
if (!customElements.get('product-filter')) {
  class ProductFilter extends HTMLElement {
    connectedCallback() {
      this.sectionId = this.dataset.sectionId;
      this.sectionEl = document.getElementById(`shopify-section-${this.sectionId}`);
      this.autoSubmit = this.dataset.autoSubmit === 'true';

      // Find elements
      this.drawer = this.querySelector(`[data-drawer="filter-drawer-${this.sectionId}"]`);
      this.openBtn = this.querySelector('.product-filter__open');
      this.formBar = this.querySelector(`#BarFiltersForm-${this.sectionId}`);
      this.formDrawer = this.querySelector(`#DrawerFiltersForm-${this.sectionId}`);

      this.initForms();
      this.initPills();
      this.initPriceRange();
      if (this.dataset.autoFill === 'true') this.initAutofill();
    }

    /* ── FORMS ──────────────────────────────────────────────────────────── */
    initForms() {
      [this.formBar, this.formDrawer].forEach(form => {
        if (!form) return;

        form.addEventListener('change', (e) => {
          // Sync checkbox between bar and drawer
          this.syncCheckbox(e.target);
          
          if (this.autoSubmit) {
            // Auto-submit ON: page navigation
            form.submit();
          } else {
            // Auto-submit OFF: AJAX update
            this.fetchFiltered(this.buildUrl(form));
          }
        });

        form.addEventListener('submit', (e) => {
          // "Toepassen" button has data-mode="page" -> let it through
          if (e.submitter?.dataset.mode === 'page') return;
          
          e.preventDefault();
          this.fetchFiltered(this.buildUrl(form));
        });
      });

      // Bar accordion behavior
      this.initBarAccordion();
    }

    syncCheckbox(input) {
      if (input.type !== 'checkbox') return;
      const otherForm = input.closest('form') === this.formBar ? this.formDrawer : this.formBar;
      if (!otherForm) return;
      
      const match = otherForm.querySelector(`input[name="${input.name}"][value="${input.value}"]`);
      if (match) match.checked = input.checked;
    }

    initBarAccordion() {
      const groups = this.formBar?.querySelector('.facets__groups');
      if (!groups) return;

      groups.addEventListener('click', (e) => {
        const summary = e.target.closest('summary');
        if (!summary) return;
        const detail = summary.parentElement;
        if (!detail?.matches('details.facet')) return;

        e.preventDefault();
        const wasOpen = detail.hasAttribute('open');
        groups.querySelectorAll('details.facet[open]').forEach(el => el.removeAttribute('open'));
        if (!wasOpen) detail.setAttribute('open', '');
        
        // Re-measure after accordion state change
        this._measure?.();
      });

      document.addEventListener('click', (e) => {
        if (!groups.contains(e.target)) {
          groups.querySelectorAll('details.facet[open]').forEach(el => el.removeAttribute('open'));
          this._measure?.();
        }
      });
    }

    /* ── PILLS ──────────────────────────────────────────────────────────── */
    initPills() {
      this.sectionEl?.addEventListener('click', (e) => {
        const pill = e.target.closest('[data-active-pills] a.pill');
        if (!pill) return;
        
        e.preventDefault();
        this.fetchFiltered(new URL(pill.href, location.origin));
      });
    }

    /* ── PRICE RANGE ────────────────────────────────────────────────────── */
    initPriceRange() {
      this.querySelectorAll('[data-price-range]').forEach(container => {
        const rangeMin = container.querySelector('[data-range-min]');
        const rangeMax = container.querySelector('[data-range-max]');
        const inputMin = container.querySelector('[data-input-min]');
        const inputMax = container.querySelector('[data-input-max]');

        if (!rangeMin || !rangeMax || !inputMin || !inputMax) return;

        // Range slider -> Input sync
        rangeMin.addEventListener('input', () => {
          const minVal = parseInt(rangeMin.value);
          const maxVal = parseInt(rangeMax.value);
          if (minVal > maxVal) rangeMin.value = maxVal;
          inputMin.value = rangeMin.value;
        });

        rangeMax.addEventListener('input', () => {
          const minVal = parseInt(rangeMin.value);
          const maxVal = parseInt(rangeMax.value);
          if (maxVal < minVal) rangeMax.value = minVal;
          inputMax.value = rangeMax.value;
        });

        // Input -> Range slider sync
        inputMin.addEventListener('input', () => {
          const val = parseInt(inputMin.value) || 0;
          rangeMin.value = Math.min(val, parseInt(rangeMax.value));
        });

        inputMax.addEventListener('input', () => {
          const val = parseInt(inputMax.value) || parseInt(rangeMax.max);
          rangeMax.value = Math.max(val, parseInt(rangeMin.value));
        });
      });
    }

    /* ── URL BUILDING ───────────────────────────────────────────────────── */
    buildUrl(form) {
      const url = new URL(location.pathname, location.origin);
      
      // Add all form data
      const formData = new FormData(form);
      formData.forEach((value, key) => {
        if (value) url.searchParams.append(key, value);
      });

      // Always start at page 1 when filtering
      url.searchParams.delete('page');

      return url;
    }

    /* ── AJAX FETCH ─────────────────────────────────────────────────────── */
    async fetchFiltered(url) {
      // Add section parameter for Section Rendering API
      const fetchUrl = new URL(url);
      fetchUrl.searchParams.set('sections', this.sectionId);

      document.documentElement.classList.add('is-loading');

      try {
        const response = await fetch(fetchUrl.toString());
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const data = await response.json();
        const newHTML = data[this.sectionId];
        
        if (!newHTML) throw new Error('No section data');

        // Parse new HTML
        const parser = new DOMParser();
        const newDoc = parser.parseFromString(newHTML, 'text/html');

        // Update product grid
        const newGrid = newDoc.querySelector('[data-product-grid]');
        const currentGrid = this.sectionEl.querySelector('[data-product-grid]');
        if (newGrid && currentGrid) {
          currentGrid.innerHTML = newGrid.innerHTML;
        }

        // Update pills
        const newPills = newDoc.querySelector('[data-active-pills]');
        const currentPills = this.sectionEl.querySelector('[data-active-pills]');
        if (newPills && currentPills) {
          currentPills.outerHTML = newPills.outerHTML;
        }

        // Update result counts (all instances)
        const newCount = newDoc.querySelector('[data-facets-resultcount]');
        if (newCount) {
          this.sectionEl.querySelectorAll('[data-facets-resultcount]').forEach(el => {
            el.innerHTML = newCount.innerHTML;
          });
        }

        // Sync facet states (counts, disabled, checked)
        this.syncFacetStates(newDoc);

        // Update browser URL
        history.replaceState({}, '', url.toString());

      } catch (error) {
        console.error('[ProductFilter] AJAX failed:', error);
        // Fallback: navigate to URL
        location.href = url.toString();
      } finally {
        document.documentElement.classList.remove('is-loading');
      }
    }

    syncFacetStates(newDoc) {
      // Sync bar form
      const newBar = newDoc.querySelector('.facets--bar');
      if (newBar && this.formBar) {
        this.syncFormFacets(this.formBar, newBar);
      }

      // Sync drawer form
      const newDrawer = newDoc.querySelector('.facets--drawer');
      if (newDrawer && this.formDrawer) {
        this.syncFormFacets(this.formDrawer, newDrawer);
      }
    }

    syncFormFacets(currentForm, newForm) {
      currentForm.querySelectorAll('li[data-value]').forEach(currentLi => {
        const param = currentLi.closest('[data-param]')?.dataset.param;
        const value = currentLi.dataset.value;
        if (!param || !value) return;

        const newLi = newForm.querySelector(
          `[data-param="${CSS.escape(param)}"] li[data-value="${CSS.escape(value)}"]`
        );
        if (!newLi) return;

        // Update count
        const currentQty = currentLi.querySelector('.facet__qty');
        const newQty = newLi.querySelector('.facet__qty');
        if (currentQty && newQty) {
          currentQty.textContent = newQty.textContent;
        }

        // Update input state
        const currentInput = currentLi.querySelector('input');
        const newInput = newLi.querySelector('input');
        if (currentInput && newInput) {
          currentInput.checked = newInput.checked;
          currentInput.disabled = newInput.disabled;
        }

        // Update label classes
        const currentLabel = currentLi.querySelector('.facet__check');
        const newLabel = newLi.querySelector('.facet__check');
        if (currentLabel && newLabel) {
          currentLabel.className = newLabel.className;
        }
      });
    }

    /* ── AUTOFILL (responsive bar) ──────────────────────────────────────── */
    initAutofill() {
      const groups = this.formBar?.querySelector('.facets__groups');
      if (!groups) return;

      // Get the parent container that has the fixed width
      const container = this.formBar?.closest('.product-filter__preview');
      if (!container) return;

      const measure = () => {
        const max = parseInt(this.dataset.maxPreview, 10) || 99;
        const items = [...groups.querySelectorAll('details.facet')];
        if (!items.length) return;

        // Step 1: Show all items first to measure them
        items.forEach(el => el.classList.remove('facet--hidden'));

        // Step 2: Calculate available width for facets
        // Container width minus other elements (sort, resultcount, filter button, gaps)
        const containerWidth = container.offsetWidth;
        const filterBtn = container.querySelector('.product-filter__open');
        const sortSelect = this.formBar.querySelector('.facets__sort');
        const resultCount = this.formBar.querySelector('.facets__resultcount');
        
        let reservedWidth = 0;
        if (filterBtn) reservedWidth += filterBtn.offsetWidth + 16; // + gap
        if (sortSelect) reservedWidth += sortSelect.offsetWidth + 8;
        if (resultCount) reservedWidth += resultCount.offsetWidth + 8;
        reservedWidth += 32; // extra padding/safety margin

        const availableWidth = containerWidth - reservedWidth;

        // Step 3: Measure each item's width
        const gap = parseFloat(getComputedStyle(groups).columnGap) || 8;
        let usedWidth = 0;
        let visibleCount = 0;

        items.forEach((el, i) => {
          if (i >= max) {
            el.classList.add('facet--hidden');
            return;
          }

          const itemWidth = el.offsetWidth + (i > 0 ? gap : 0);
          
          if (usedWidth + itemWidth <= availableWidth) {
            usedWidth += itemWidth;
            visibleCount++;
          } else {
            el.classList.add('facet--hidden');
          }
        });

        // Step 4: Update badge with hidden count
        const hiddenCount = items.length - visibleCount;
        let badge = this.openBtn?.querySelector('.badge');
        
        if (!badge && this.openBtn) {
          badge = document.createElement('span');
          badge.className = 'badge';
          this.openBtn.appendChild(badge);
        }
        
        if (badge) {
          badge.textContent = hiddenCount > 0 ? `+${hiddenCount}` : '';
          badge.hidden = hiddenCount <= 0;
        }
      };

      // Store measure function
      this._measure = measure;

      // Initial measure after fonts load
      if (document.fonts?.status === 'loaded') {
        requestAnimationFrame(measure);
      } else {
        document.fonts?.ready.then(() => requestAnimationFrame(measure));
      }

      // Re-measure on resize
      this._resizeObserver = new ResizeObserver(() => {
        requestAnimationFrame(measure);
      });
      this._resizeObserver.observe(container);
    }
  }

  customElements.define('product-filter', ProductFilter);
}
</script>

{% schema %}
{
	"name": "Collection products",
	"tag": "section",
	"class": "block-collection-products",
	"enabled_on": {
		"templates": ["collection", "search"]
	},
	"settings": [
		{ "type": "header", "content": "Layout" },
		{
			"type": "select",
			"id": "width",
			"label": "Width",
			"options": [
				{ "value": "alignsmall", "label": "Narrow" },
				{ "value": "align", "label": "Regular" },
				{ "value": "alignwide", "label": "Wide" },
				{ "value": "alignfull", "label": "Full" }
			],
			"default": "alignwide"
		},
		{
			"type": "range",
			"id": "grid_columns",
			"label": "Columns (desktop)",
			"min": 1,
			"max": 4,
			"step": 1,
			"default": 4
		},
		{
			"type": "select",
			"id": "grid_columns_tablet",
			"label": "Columns (tablet)",
			"options": [
				{ "value": "1", "label": "1" },
				{ "value": "2", "label": "2" },
				{ "value": "3", "label": "3" }
			],
			"default": "3"
		},
		{
			"type": "select",
			"id": "grid_columns_mobile",
			"label": "Columns (mobile)",
			"options": [
				{ "value": "1", "label": "1" },
				{ "value": "2", "label": "2" }
			],
			"default": "2"
		},
		{
			"type": "range",
			"id": "grid_gap",
			"label": "Grid gap",
			"min": 0,
			"max": 2,
			"step": 0.2,
			"default": 0.2,
			"unit": "em"
		},
		{
			"type": "range",
			"id": "products_per_page",
			"label": "Products per page",
			"min": 8,
			"max": 48,
			"step": 4,
			"default": 24
		},
		{ "type": "header", "content": "Filtering" },
		{
			"type": "checkbox",
			"id": "show_filter",
			"label": "Show filters",
			"default": true
		},
		{
			"type": "checkbox",
			"id": "show_sort",
			"label": "Show sorting",
			"default": true
		},
		{
			"type": "checkbox",
			"id": "show_result_count",
			"label": "Show result count",
			"info": "Display total number of products above the grid",
			"default": true
		},
		{
			"type": "checkbox",
			"id": "show_filter_counts",
			"label": "Show filter counts",
			"info": "Display product count next to each filter value",
			"default": true
		},
		{
			"type": "checkbox",
			"id": "hide_empty_values",
			"label": "Hide unavailable values",
			"info": "Hide filter values with zero matching products",
			"default": false
		},
		{
			"type": "range",
			"id": "max_preview_filters",
			"label": "Max filters in bar",
			"info": "Additional filters accessible via drawer",
			"min": 1,
			"max": 10,
			"step": 1,
			"default": 8
		},
		{
			"type": "checkbox",
			"id": "auto_fill_preview",
			"label": "Auto-fit bar filters",
			"info": "Automatically hide filters that don't fit in the bar",
			"default": true
		},
		{
			"type": "checkbox",
			"id": "collapse_bar_mobile",
			"label": "Collapse bar on mobile",
			"info": "Show only the drawer button on small screens",
			"default": true
		},
		{
			"type": "checkbox",
			"id": "auto_submit",
			"label": "Auto-submit on change",
			"info": "Navigate to filtered page immediately (instead of AJAX)",
			"default": false
		},
		{ "type": "header", "content": "Product card" },
		{
			"type": "select",
			"id": "card_layout",
			"label": "Card layout",
			"options": [
				{ "value": "vertical", "label": "Vertical" },
				{ "value": "horizontal", "label": "Horizontal" }
			],
			"default": "vertical"
		},
		{
			"type": "select",
			"id": "image_ratio",
			"label": "Image ratio",
			"options": [
				{ "value": "adapt", "label": "Adapt" },
				{ "value": "square", "label": "Square (1:1)" },
				{ "value": "portrait", "label": "Portrait (2:3)" },
				{ "value": "landscape", "label": "Landscape (3:2)" }
			],
			"default": "adapt"
		},
		{
			"type": "checkbox",
			"id": "show_secondary_image",
			"label": "Show secondary image on hover",
			"default": true
		},
		{
			"type": "checkbox",
			"id": "show_rating",
			"label": "Show rating",
			"default": false
		},
		{
			"type": "checkbox",
			"id": "show_vendor",
			"label": "Show vendor",
			"default": false
		},
		{
			"type": "checkbox",
			"id": "show_badges",
			"label": "Show badges",
			"default": true
		},
		{
			"type": "checkbox",
			"id": "quick_add",
			"label": "Show quick add button",
			"default": false
		},
		{ "type": "header", "content": "Colors" },
		{
			"type": "color",
			"id": "background_color",
			"label": "Background",
			"default": "#f8f8f8"
		},
		{
			"type": "color",
			"id": "text_color",
			"label": "Text",
			"default": "#111111"
		}
	],
	"presets": [
		{
			"name": "Products",
			"category": "Collection"
		}
	]
}
{% endschema %}
